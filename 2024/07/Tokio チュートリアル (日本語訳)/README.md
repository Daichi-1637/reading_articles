# 2024/07/08 Tokio チュートリアル

- link: https://zenn.dev/magurotuna/books/tokio-tutorial-ja/viewer/preface

以下, メモ

## イントロ

- このチュートリアルはRedisクライアントとサーバを作る過程を通して進んでいく
    - Redis: DB管理システム

## Hello Tokio

- 同期プログラミングは, プログラムが即座に終了しない処理に差し掛かった際に, その処理が完了するまでブロックされる
- 非同期プログラミングは, 即座に完了しない処理はバックグラウンドで中断される.
    - スレッドはブロックされず, 別の処理を実行することができる.
    - 一通りの処理が完了したら, バックグラウンドにいったタスクが復帰し, 中断されたところから処理が再開される.
- Rust はコンパイル時に `async fn` 非同期処理を行うルーチンへと変換する
- `.await` を呼び出すと, スレッドに制御が戻る
- `async fn` の返り値はFutureトレイトを実装する無名型

```rust
// 以下, 二つの関数は同義

#[tokio::main]
async fn main() {
  println!("hello");
}

fn main() {
  let mut rt = tokio::runtime::Runtime::new().unwrap();
  rt.block_on(async {
    println!("hello");
  })
}
```

**まとめ**

- 非同期プログラミングの説明
    - 即座に完了しない処理を後回しにする
- Rustでは, コンパイル時に `async fn` を非同期処理を行うルーチンへと変化させる
- `.await` を呼び出すとスレッドの制御が戻る

## Spawning

- 現状のコードでは1度に1つのインバウンドリクエストしか捌けない
- 並列性と並行性
    - 並行: 2つのタスクを交互に行う
    - 並列: 2人の人間が別々のタスクを進める
- Tokioでは, 並列ではなく並行して処理を行うことができる
    - 単一スレッドであったとしても並行で行える
- `tokio::handle` 関数は `JoinHandler` を返し, これを使うことでspawnされたタスクとやり取りをすることができるようになる
- `JoinHandler` に対して, `.await` をすることで, この返り値を取得することができる
    - 返り値としては, `Result` 型
    - タスクがエラーに遭遇した場合には, Errを返す
- タスクとは, スケジューラによって管理される実行単位
    - タスクをspawnするとTokioのスケジューラにそれが登録され, 適切なタイミングでタスクが実行されるこが保証される.
- spawnされたタスクについて,
    - spawnされたタスクは, spawnされたスレッドと同一のスレッド上で実行されることもある
    - ランタイム上の異なるスレッドで実行されることもある.
    - spawnされた後にスレッド間を行き来することもある
- タスクは64バイトのメモリしか消費しない
    - 量産できる
- Tokioのランタイム上でタスクをspawnするとき, その型は `'static` でなければならない.
    - つまり, そのタスクは, タスクの外で所有されるデータへのいかなる参照をも含んではならない
- https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md#2-if-t-static-then-t-must-be-valid-for-the-entire-program
    - `'static T` は, プログラムの終了までを含めて, 無期限に安全に保持できるT.
        - 不変でコンパイル時のみに生成される
        - プログラム全体で有効になる
        - 所有者がデータを保持している限り, データが無効になることがないことを保証する
    - `&'static T` は, プログラムの終了までを含め, 無期限に安全に保持できるTへの不変参照
        - T自体が不変. 参照の作成後に移動しない場合にのみ可能.
- 変数はデフォルトでは `async` ブロックにムーブされない
    - ブロックに入った途端にタスクの内部で利用しているすべてのデータは `'static` になる
    - `move` ブロックで囲めば, ムーブできるらしい
- spawnされるタスクは必ず `Send` トレイトを実装していなければならない
    - `.await` によってタスクが一時的に中断されているときに, Tokioランタイムがそのタスクを別のスレッドにいどうできるようにするため

**まとめ**

- Tokioは並行処理を実現している
- `tokio::handle` 関数は `JoinHandle` を返す.
    - `JoinHandle` に `.await` をつけることでResult型が返され, 値をとりだすことができる.
- Tokioのタスクのライフタイムは, `'static` であるため変数をムーブするときには注意が必要.

## 状態を共有する

- Byte型は, Vec<u8>に対して浅いクローンを追加しているらしい
    - cloneしても内部のデータはコピーされない
    - 内部で参照カウンタを持つらしい
- tokioでは, 何らかの共有ステートへのアクセスを提供する値を**ハンドル**というらしい.
- `current_thread` ランタイムは軽量なシングルスレッドランタイム.
    - わずかなソケットを開くだけなどの場合にはこの選択が良いらしい
- シャーディング
    - データベースの負荷分散の手法の一つ
    - 1つのテーブルを複数の物理コンピュータに分割して記録する方式
- シャーディングの話はよく分からんかった

**まとめ**

- Tokioでは, 何らかの共有ステートへのアクセスを提供する値を**ハンドル**という
    - `JoinHandle` もその一種？
    - ハンドルを返して状態を知ることができる
- おそらく各スレッド間で変数を共有するときにどうするか, みたいな話をしたいのだろうがよくわからなかった.
    - Mutex等々の話っぽい. 理解できてないからかも

## チャネル

- クラインアントサイドで並行処理を実現する際に, `Copy` トレイトを実装していないので, client変数を共有してしようできない.
    - 加えて, Client::setでは, `&mut self` をとっているらしい
    - とどのつまり, 何かしらの工夫が必要！
- メッセージ受け渡しパターンを使うと, `client` リソースをかんりするための専用タスクをspawnできる.
    - このタスクは, リクエスト送信者の代わりにリクエストを発行し, 送信者にレスポンスを送ってくれるらいい
    - proxyみたいなタスク？
- Tokioが持つチャネル
    - mpsc: multi-producer, signal-consumer
        - たくさんの値を送ることができる
    - oneshot: single-producer, single-consumer
        - 1つの値を送ることができる
    - broadcast: multi-producer, multi-consumer
        - 受信側はすべての値をみることができる
    - watch: single-producer, multi-consumer
        - たくさんの値を送ることができるが, 履歴はのこらない. 受信側は最新の値のみを見ることができる.
- チャンネルのキャパシティは, 送信用のメッセージを蓄えておけるメッセージの個数を表しているらしい
    - 蓄えの上限数を超えると, 受信者によってメッセージが読み込まれるまで, スリープする.
- メッセージはすべて一つの受信者へと送られる
    - 受信者をクローンすることはできない

**まとめ**

- クライアントサイドからのつなぎ口の話

## I/O

- `AsyncRead` 非同期の読み込みを実現するトレイト
- `AsyncWrite` 非同期の書き込みを実現するトレイト
- `AsyncReadExt::read`
    - `read()` がOk(0)を返して来たら, そのストリームが閉じられたことを意味するらしい
    - それ以上実行しても同じ値が返ってくるだけ
- その他いろいろあるが, 基本的にstdのioと同じなので, スルー！
- `io::split`
    - `AsyncRead` + `AsyncWrite` を実装している値に対応しており, 独立したハンドルを返すことができる
    - これを実現するためには, `Arc` と `Mutex` が使われている
    - `TcpStream` を使うとこのオーバヘッドを回避できる
        - Streamの場合には, splitに参照を渡すらしい

## フレーミング

- フレーミング
    - バイトストリームを受け取ってそれをフレームのストリームへと変換すること
    - フレームは2つのピアの間で伝達されるデータの単位
- `read_frame` メソッドはフレーム全体を受け取るまで待機してから値を返す.
    - その際, データの大きさは定義されていないため, フレームの途中であったり, 複数のフレームかもしれない

## Async をさらに掘り下げる

- 以上のチャプターでまずまずの包括的なツアーは完了したらしい
- 以降はrustの非同期ランタイムモデルについてさらに深堀をする
- 非同期関数からは `feature` という値が返ってくる
    - featureは**計算そのもの**が返される
    - featureの所有者は, futureに対してポーリングを行うことで計算を進める責任を負っています
- もっとも外側のfutureをpollするのが `#[tokio::main]`
- waker
    - リソースからそれを待ち受けているタスクに対して, リソースの準備が整って, 続きの処理を行うことができるようになったことを通知することを可能にするシステム
- Sync型
    - 不変参照を通して, 並列にアクセスされても問題ない型
- コードを読む
    - main関数の中でmini_tokioを生成し, spawnメソッドを呼び出している
    - spawnメソッドは, future型を受け取る
        - Closureみたいなもの.
        - 呼び出し元は, こいつをいずれ呼び出す責務をもつ.
    - MiniTokioのspawnメソッドは, Taskのspawn型関連関数を呼び出している.
        - 引数のfutureの実態は,
        `Mutex<Pin<Box<dyn Future<Output = T> + Send + ‘static>>`