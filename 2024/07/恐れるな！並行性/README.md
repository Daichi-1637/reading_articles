# 2024/07/13 恐れるな！並行性

リンク: https://doc.rust-jp.rs/book-ja/ch16-00-concurrency.html#恐れるな並行性

- 並行プログラミング
    - プログラムの異なる部分が独立して実行すること
- 並列プログラミング
    - プログラムの異なる部分が同時に実行すること

### スレッドを使用してコードを同時に走らせる

- 実行中のプログラムのコードは**プロセス**で走り, OSは同時に複数のプロセスを管理する
- 自分のプログラム内で, 独立した部分を同時に走らせる機能を**スレッド**とよぶ
- プログラミング言語が提供するスレッドは, **グリーンスレッド**として知られ, それを異なる数のOSスレッドの文脈で実行する. このモデルは **M:N**モデルと呼ばれる.
    - M個のグリーンスレッドに対して, N個のOSスレッドモデルがある.
- **グリーンスレッド**: 言語が独自で実装している仮想的なスレッド.
- **ランタイム**: 言語によってすべてのバイナリに含まれているコード.
- `thread::spawn` でスレッドを立ち上げてプロセスを走らせることができるらしい
- `thread::sleep` を呼び出すと, スレッドの実行を止めて, 別のスレッドを走らせることができるらしい
- `thread::spawn` は立ち上げたは良いものの, 実行順を保証できない
    - `thread::spawn` の戻り値の `JoinHandler`を見ることで状態を監視できる
    - `JoinHalder::join` を呼び出すと, そのスレッドが終了するまで実行中のスレッドをブロックできる.
- クロージャの前に `move` キーワードを付けることで, コンパイラに値を借用すべきと推論させ, クロージャに使用している値の所有権を強制的に奪わせる.
    - この際, 値のライフタイムは `'static` になる？

### メッセージ受け渡しを使ってスレッド間でデータを転送する

- メッセージ渡し
    - メモリを共有することでやり取りをするな, 代わりにやり取りをすることでメモリを共有しろ
- **チャネル**
    - 受信機と転送機がある. 入口と出口.
    - どちらかがドロップされると, チャネルは閉じられるらしい
        - ドロップされ限りはずっといる
    - producer: 送信側, consumer: 受信側
    - `recv` メソッドはチャンネルからのデータを受け取るまで処理を待ってくれるらしい

### 状態共有並行性

- Mutex
    - mutual exclusion（相互排他）の略
    - どんな時も1つのスレッドにしか何らかのデータへのアクセスを許可しない
- mutexは2つの規則を覚えておく必要がある
    - データを使用する前にロックの獲得を試みなければならない
    - mutexが死守しているデータの使用が終わったら, 他のスレッドがロックを獲得できるように, データをアンロックしなければならない
- mutexでロックをとっている間は, そのmutex型の値の所有権を移動することはできない
- `Rc` は参照カウンタ
    - 並列処理で使用するには適していない
    - 参照カウンタの足し引きが各スレッドからアクセスされることで狂ってしまう可能性があるから
- `Arc` は並列な状況でも安全に使用できる参照カウンタ
    - aはアトミック
    - アトミックについての詳細は, `std::sync::atomic` の標準ライブラリドキュメントを見る！

### SyncとSendトレイトで拡張可能な並行性

- `Send` マーカトレイト
    - `send` を実装した型の所有権をスレッド間で転送できることを示唆する
- `Sync` マーカトレイト
    - 複数のスレッドから参照されても安全であることを示唆する
    - `&T` がSendなら, 型 `T` はSyncであり, 参照がほかのスレッドに安全に送信できることを意味する
- 上記のトレイトを自分で実装するべきではない
    - unsafeになる